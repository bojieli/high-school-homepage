　
河北信息学竞赛
　
　
――李博杰  主管   肖世康  协办――
　
　您的位置：博杰学习网>>学科竞赛>>信息学（内部资料，绝密）
第一届石家庄二中NOIP模拟赛
　
　
　
本届模拟赛已于4月20日举行。
命题人：李博杰
　
　
竞赛结果
姓名得分
李博杰400
郑达280
吴鹏280
贾上250
刘延珍210
孟赫200
魏达200
石武120

注：卢思达、廖若晨未参赛。
　
　
　
　
模拟赛试题
　
请尊重他人知识产权，版权所有，不得随意复制、更改！
　
　
　
石家庄二中NOIP模拟赛
提高组
命题人：李博杰
 
题目一览
题目名称取棋子游戏数字识别小明学算术拦截导弹
代号gamenumaddmil
输入文件game.innum.inadd.inmil.in
输出文件game.outnum.outadd.outmil.out
时限1秒1秒1秒1秒

 
说明：
1、     文件名（程序名和输入输出文件名）必须是小写。
2、     C/C++中函数main()的返回值类型必须是int，程序正常结束时的返回值必须是0。
3、     统一评测使用的机器配置是CPU 3.06GHz，内存256M，Windows XP Professional SP2，CENA测试器。
4、     输入输出必须严格按照标准，不得有多余的空格与换行。
5、     考试时间为3小时，满分400分。
6、     每题10个测试数据，每个测试数据10分，只有程序得出的答案与标准答案完全相符时才能得分。
7、     只提交编译后的.exe可执行文件。对未编译或因编译错误而导致的结果不正确，我们将不予重新评测。
8、     严禁对规定输入输出以外的任何文件进行读写操作，否则取消本题成绩。
 
 
 
 
 
 
 
 
 
 
 
1、取棋子游戏
(game.pas/c/cpp)
【问题描述】
甲、乙两人轮流从两堆棋子中取棋子，满足下列要求：或者从一堆中取出任意多枚（至少一枚）棋子，或只从两堆中取出同样数目（至少一枚）的棋子，将两堆取完并取到最后一枚棋子者获胜。问：在什么情况下，甲（先取者）有必胜策略？
 
【输入文件】
输入文件game.in只有一行，包含两个用空格隔开的整数表示两堆棋子的个数（每堆棋子至少一个，至多10000个）。
 
【输出文件】
输出文件game.out只有一行，包含一个字符。若先取者有必胜策略，输出“Y”（不含引号）；否则，输出“N”（不含引号）。
 
【样例输入1】
1 1
【样例输出1】
Y
 
【样例输入2】
5 3
【样例输出2】
N
 
【友情提示】
用数学方法解决。也可先对小数据枚举，然后发现规律。
 
 
 
 
 
 
 
 
 
 
 
 
2、数字识别
（num.pas/c/cpp）
【问题描述】
手写数字识别(Handwritten Numeral Recognition)是光学字符识别技术(Optical Character Recognition，简称OCR)的一个分支，它研究的对象是，如何利用电子计算机自动辨认人手写在纸张上的阿拉伯数字。 
在整个OCR领域中，最为困难的就是脱机手写字符的识别，到目前为止，尽管人们在脱机手写英文、汉字识别的研究中已取得很多可喜成就，但距实用还有一定距离。而在手写数字识别这个方向上，经过多年研究，研究工作者已经开始把它向各种实际应用推广。 
现在你的任务就是编写一个简单的数字识别程序。
为了降低难度，我们约定笔迹都是直线，且互相垂直；为了便于处理，所有点都用01矩阵表示。1表示有笔迹，0表示空白。
各数字的样式遵从普通计算器屏幕的模式。输入中数字大小、笔画长度不一定相同，但笔画方向必定相同。笔画的宽度都是1。横向各笔画长度均相等。保证输入的矩阵所代表数字0-9，符合规范，没有多余的空格和字符。
【输入文件】
输入文件num.in第一行为矩阵的长宽n,m。(0<n<=10,0<m<=10)
以下n行每行m个无空格的字符0或1，表示该点有无笔迹。
【输出文件】
输出文件num.out只有一个数字，即所识别出的数字(是0,1,2...9中的一个)。
【样例输入1】
8 5
00000
11111
00001
11111
10000
10000
10000
11111
【样例输出1】
2
【样例输入2】
1 1
1
【样例输出2】
1
【友情提示】
寻找各数字的特点，分别判断。
 
3、小明学算术
(add.pas/c/cpp)
【问题描述】
小明最近接到了一项算数的作业。黑板上初始时只有一个数1。每次取在黑板上的任意两个数（可以相同）相加，得到另一个数，要求这个数比黑板上已有的任意一个数都大，并把所得的符合要求的和数也写在黑板上。这称为一次操作。当黑板上首次出现指定的整数n(2<=n<=1000)时，停止操作。
小明的加法学得很不好，算一次加法需要很长时间。他希望学编程的你找到一种方案，用最少的操作次数得出指定的数n。
 
【输入文件】
输入文件add.in只有一行。包含一个整数n(2<=n<=1000)，表示指定的整数。
 
【输出文件】
输出文件add.out包含两行。第一行一个整数，表示最少操作次数。第二行若干个空格隔开的整数，表示操作结束时黑板上的所有数，按从小到大的顺序输出。若有多组符合要求的解，输出次大的数最大的一组；若还多解，输出第三大的数最大的一组；以此类推。
 
【样例输入1】
2
【样例输出1】
1
1 2
 
【样例输入2】
200
【样例输出2】
9
1 2 4 8 16 32 64 128 192 200
 
【友情提示】
注意对搜索的优化，以免超时。
 
 
 
 
 
 
 
 
 
4、拦截导弹
（mil.pas/c/cpp）
【问题描述】
某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都必须严格小于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。
输入导弹依次飞来的高度（雷达给出的高度数据是不大于100000的正整数），计算这套系统最多能拦截多少导弹。
 
【输入文件】
输入文件mil.in包括两行，第一行一个整数n(1<=n<=100000)，表示导弹的个数。第二行n个用空格隔开的整数，表示导弹依次飞来的高度（不大于100000的正整数）。
 
【输出文件】
输出文件mil.out只有一行，包含一个整数，表示这套系统最多能拦截的导弹数。
 
【样例输入1】
1
1
【样例输出1】
1
 
【样例输入2】
8
389 207 155 300 299 170 158 65
【样例输出2】
6
 
【数据规模】
对于40%的数据，1<=n<=1000；
对于100%的数据，1<=n<=100000。
 
【友情提示】
注意对动态规划的优化，以免超时。
　
　
　
标程源代码
　
请尊重他人知识产权，版权所有，不得随意复制、更改！
//game.c
#include<stdio.h>
#include<math.h>
int main()
{ int i,a,b,t;
double x=(1+sqrt(5))/2,y=(3+sqrt(5))/2;
FILE *fp,*fp1;
fp=fopen("game.in","r");
fp1=fopen("game.out","w");
fscanf(fp,"%d%d",&a,&b);
if(a>b)
{ t=a;
a=b;
b=t;
}
for(i=0;i<10000;i++)
if((int)(x*i)==a&&(int)(y*i)==b)
break;
if(i==10000)
fprintf(fp1,"Y");
else fprintf(fp1,"N");
fclose(fp);
fclose(fp1);
return 0;
} 
　
//num.c
#include<stdio.h>
int a[4][2];
char x[11][11];
int num()
{ int i;
if(a[0][0]==a[1][0]&&a[0][1]==a[1][1])
return 1;
if(a[2][0]==a[3][0]&&a[2][1]==a[3][1])
{ if(x[a[0][0]][a[0][1]+1]=='1')
return 7;
return 4;
} 
if(x[a[0][0]+1][a[0][1]]=='0')
{ if(x[a[2][0]-1][a[2][1]]=='1')
return 2;
return 3;
}
if(x[a[1][0]+1][a[1][1]]=='0')
{ if(x[a[2][0]-1][a[2][1]]=='1')
return 6;
return 5;
}
if(x[a[2][0]-1][a[2][1]]=='0')
return 9;
for(i=a[0][0]+1;i<a[2][0];i++)
if(x[i][a[0][1]+1]=='1')
return 8;
return 0;
}
int main()
{ int n,i,j,m;
FILE *fp,*fp1;
fp=fopen("num.in","r");
fp1=fopen("num.out","w");
fscanf(fp,"%d%d",&n,&m);
for(i=0;i<n;i++)
{ fscanf(fp,"\n");
for(j=0;j<m;j++)
fscanf(fp,"%c",&x[i][j]);
} 
for(i=0;i<n;i++)
{ for(j=0;j<m;j++)
if(x[i][j]=='1')
{ a[0][0]=i;
a[0][1]=j;
break;
}
if(j<m)
break;
}
for(i=0;i<n;i++)
{ for(j=m-1;j>=0;j--)
if(x[i][j]=='1')
{ a[1][0]=i;
a[1][1]=j;
break;
}
if(j>=0)
break;
} 
for(i=n-1;i>=0;i--)
{ for(j=0;j<m;j++)
if(x[i][j]=='1')
{ a[2][0]=i;
a[2][1]=j;
break;
}
if(j<m)
break;
} 
for(i=n-1;i>=0;i--)
{ for(j=m-1;j>=0;j--)
if(x[i][j]=='1')
{ a[3][0]=i;
a[3][1]=j;
break;
}
if(j>=0)
break;
} 
fprintf(fp1,"%d",num());
fclose(fp);
fclose(fp1);
return 0;
}
　

//add.c
#include<stdio.h>
int n,num=0,x[15]={1},min=14,ans[15]={1},p[15]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192};
void solve(int now)
{ int i,j;
if(now>=min)
return; 
if(x[now-1]==n)
{ if(now<min)
{ min=now;
for(i=0;i<min;i++)
ans[i]=x[i];
}
return;
}
if(x[now-1]*p[min-now]<n)
return;
for(i=now-1;i>=0;i--)
for(j=now-1;j>=i;j--)
if(x[i]+x[j]<=n&&x[i]+x[j]>x[now-1])
{ x[now]=x[i]+x[j];
solve(now+1);
}
}
int main()
{ int i;
FILE *fp,*fp1;
fp=fopen("add.in","r");
fp1=fopen("add.out","w");
fscanf(fp,"%d",&n);
solve(1);
fprintf(fp1,"%d\n",min-1);
for(i=0;i<min-1;i++)
fprintf(fp1,"%d ",ans[i]);
fprintf(fp1,"%d",n); 
return 0;
}

//mil.c
#include <stdio.h>
int a[100001],f[100001],n,i,j,k,size;
int bsearch(int f[],int size,int a) {
int l=0,r=size-1,m;
while (l<=r) {
m=(l+r)/2;
if (a>f[m-1] && a<=f[m]) return m;
else if(a<f[m]) r=m-1;
else l=m+1;
}
}
int main() {
FILE *fp,*fp1;
char name[100],name1[100];
fp=fopen("mil.in","r");
fp1=fopen("mil.out","w");
fscanf(fp,"%d",&n);
for (i=0;i<n;i++) fscanf(fp,"%d",&a[n-i-1]);
f[0]=a[0]; size=1;
for (i=1;i<n;i++) {
if (a[i]<=f[0]) j=0;
else if (a[i]>f[size-1]) j=size;
else j=bsearch(f,size,a[i]);
f[j]=a[i];
if (j==size) size++;
}
fprintf(fp1,"%d",size);
fclose(fp);
fclose(fp1);
return 0;
}
　
　

　　
Copyright （C） 2008 石家庄二中校友会 博杰学习网
　

　 
　
 